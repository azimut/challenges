* cryptopals

- Home https://cryptopals.com/
- Tour Videos https://www.youtube.com/playlist?list=PLWvDpnCcem1P6i8pZm2x7KHp5iaxwrK_P

** Problem Set 1

https://cryptopals.com/sets/1

*** Convert hex string to base64.

  - What?
    - decode hex string to bytes
    - encode bytes to base64
  - How?
    - I used C, reading 6 bits at the time, with bitwise operations.
    - With the help of [[https://bitwisecmd.com/][bitwisecmd]].

*** XOR hex strings

  - What?
    - decode hex strings to bytes
    - [[https://en.wikipedia.org/wiki/Bitwise_operations_in_C][XOR]] bytes
    - encode back to hex string

*** Single-byte XOR cipher

  - What?
    - decode hex string to bytes
    - XOR bytes with a single byte
    - measure result for likelyhood of a real msg
    - repeat with a different byte
    - return the result with highest score
  - How?
    - use [[https://en.wikipedia.org/wiki/Letter_frequency][letter frequency]] analysis to determine a score for each result
    - use one for english language

*** Detect single-character XOR

  - What?
    - We are given a list of strings
    - Only 1 is XOR'd
    - Figure out which one
  - How?
    - I can't just guess. I needed to improve my scoring algorithm.
    - Found this algorithm/guide https://inventwithpython.com/cracking/chapter19.html
      - Gets a score by counting matches between the 6 most common and 6 most uncommon letters in english.
      - But it didn't give me great results.
    - Found this other one https://wgallagher86.medium.com/single-byte-xor-decryption-and-detection-in-go-451e1c9c52ec
      - Specificaly targetting this exercise.

*** Implement repeating-key XORImplement repeating-key XOR

  - What?
    - apply a XOR key of multiple bytes
    - it's one pass
    - and the bytes of the key cycle
  - How?
    - This turned out pretty easy in comparison now that I have the Buffer class ironed out.

*** Break repeating-key XOR

  - What?
    - I am a given a file with a 80-width max formatted *base64* string.
    - It represents a *repeating-key* XOR'd english message.
    - I need to figure out the more likely *keylength* using *hamming distance*
    - Then bruteforce the key, by bruteforcing each XOR digit one at the time.
  - How?
    - Read the whole file as a single string.
    - Improve my previous *base64* code to decode and encode to support padding.

*** AES in ECB mode

- What?
  - You are given
    - a base64 encoded message
    - the key to decode it
    - the cipher used (AES-128-ECB)
  - You need to decode it.
- How?
  - I first assumed that it would be just a quick look at the [[https://en.wikipedia.org/wiki/Advanced_Encryption_Standard][AES]] wikipedia. But after seeing the many implementation [[https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation][details]] that will involve it. I decided to look elsewhere.
  - I found this [[https://www.scottbrady.io/cryptopals/implementing-and-breaking-aes-ecb][article]] that mentions someone trying to write AES but eventually took the library route.
  - Also the official [[https://www.youtube.com/watch?v=HKQ-Vjb4MX8][tour video]] only calls a python library. But also mentioning a [[https://cryptohack.org/][resource]] to learn how to implement it.
  - I ended up just using this C [[https://gist.github.com/dvtalk/edca1d9753503cd03f04b495b040f0e3][snippet]] that calls OpenSSL

